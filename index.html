<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Projectile Motion Simulator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --text-color: #e0e0e0;
            --accent-color: #00ff88;
            --panel-bg: rgba(0, 0, 0, 0.7);
        }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
            transition: background-color 0.5s ease;
            /* Smooth transition */
        }

        body.air-mode {
            background-color: #4682B4;
            /* Sky Blue (Steel Blue) */
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: auto;
            bottom: 20px;
            left: auto;
            right: 20px;
            background: var(--panel-bg);
            padding: 20px;
            border-radius: 12px;
            backdrop-filter: blur(5px);
            border: 1px solid #333;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            width: 280px;
        }

        h1 {
            font-size: 1.2rem;
            margin: 0 0 15px 0;
            color: var(--accent-color);
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        label {
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
            margin-bottom: 5px;
            color: #aaa;
        }

        .value-display {
            color: #fff;
            font-weight: bold;
        }

        input[type="range"] {
            width: 100%;
            cursor: pointer;
            accent-color: var(--accent-color);
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            font-size: 0.8rem;
        }

        #btn-fire {
            background-color: var(--accent-color);
            color: #000;
        }

        #btn-fire:hover {
            background-color: #00cc6a;
            transform: translateY(-1px);
        }

        #btn-fire:active {
            transform: translateY(1px);
        }

        #btn-reset {
            background-color: #444;
            color: #fff;
        }

        #btn-reset:hover {
            background-color: #555;
        }

        /* Stats Display */
        #stats-display {
            position: absolute;
            top: 20px;
            right: 20px;
            text-align: right;
            pointer-events: none;
        }

        .stat-box {
            background: var(--panel-bg);
            padding: 15px 25px;
            border-radius: 8px;
            margin-bottom: 10px;
            border: 1px solid #333;
        }

        .stat-label {
            font-size: 0.8rem;
            color: #aaa;
            text-transform: uppercase;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: var(--accent-color);
            font-family: 'Courier New', monospace;
        }

        .unit {
            font-size: 1rem;
            color: #888;
        }

        /* Tutorial/Hint */
        #hint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #666;
            font-size: 0.9rem;
            pointer-events: none;
        }

        /* Data Panel */
        #data-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            bottom: auto;
            right: auto;
            background: var(--panel-bg);
            padding: 15px;
            border-radius: 12px;
            backdrop-filter: blur(5px);
            border: 1px solid #333;
            width: 300px;
            max-height: 200px;
            overflow-y: auto;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
        }

        #data-panel h3 {
            margin: 0 0 10px 0;
            font-size: 1rem;
            color: var(--accent-color);
            border-bottom: 1px solid #444;
            padding-bottom: 5px;
        }

        /* Tabs removed, single table style */
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }

        th,
        td {
            text-align: center;
            padding: 5px;
            border-bottom: 1px solid #333;
        }

        th {
            color: #aaa;
            font-weight: normal;
        }

        td {
            color: #fff;
        }

        tr:last-child td {
            border-bottom: none;
        }
    </style>
</head>

<body>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <h1>Control Panel</h1>

        <div class="control-group">
            <label>
                Launch Angle
                <span id="angle-val" class="value-display">45째</span>
            </label>
            <input type="range" id="angle-slider" min="0" max="90" value="45">
        </div>

        <div class="control-group">
            <label>
                Fire Power
                <span id="power-val" class="value-display">15</span>
            </label>
            <input type="range" id="power-slider" min="5" max="30" value="15" step="0.5">
        </div>

        <div class="control-group">
            <label style="justify-content: flex-start; gap: 10px; cursor: pointer;">
                <input type="checkbox" id="drag-enabled" style="width: auto; accent-color: var(--accent-color);">
                Enable Air Resistance (Fixed 0.2)
            </label>
        </div>

        <div class="button-group">
            <button id="btn-reset">Reset World</button>
            <button id="btn-fire">FIRE!</button>
        </div>
    </div>

    <div id="stats-display">
        <div class="stat-box">
            <div class="stat-label">Last Distance</div>
            <div class="stat-value"><span id="distance-display">0.0</span> <span class="unit">m</span></div>
        </div>
    </div>

    <div id="data-panel">
        <h3>Flight Data</h3>
        <table id="data-table">
            <thead>
                <tr>
                    <th>#</th>
                    <th>Angle</th>
                    <th>Power</th>
                    <th>Drag</th>
                    <th>Dist.</th>
                </tr>
            </thead>
            <tbody id="data-body">
            </tbody>
        </table>
    </div>

    <div id="hint">Tip: Try 45째 for maximum range!</div>

    <script>
        // Module aliases
        const Engine = Matter.Engine,
            Render = Matter.Render,
            Runner = Matter.Runner,
            Bodies = Matter.Bodies,
            Composite = Matter.Composite,
            Events = Matter.Events,
            Vector = Matter.Vector,
            Body = Matter.Body;

        // Configuration
        const config = {
            width: window.innerWidth,
            height: window.innerHeight,
            groundHeight: 60,
            groundWidth: 50000, // Make ground very wide
            cannonPos: { x: 100, y: window.innerHeight - 60 - 20 }, // Ground height 60, cannon radius ~20
            cannonLength: 60,
            pixelsPerMeter: 20 // Scale for distance calculation
        };

        // State
        let engine, render, runner;
        let projectiles = [];
        let trails = []; // Array of {x, y} arrays

        // UI Elements
        const angleSlider = document.getElementById('angle-slider');
        const powerSlider = document.getElementById('power-slider');
        const angleVal = document.getElementById('angle-val');
        const powerVal = document.getElementById('power-val');
        const btnFire = document.getElementById('btn-fire');
        const btnReset = document.getElementById('btn-reset');
        const distanceDisplay = document.getElementById('distance-display');
        const dataBody = document.getElementById('data-body');
        const dragEnabled = document.getElementById('drag-enabled');

        let attemptCount = 0;

        function init() {
            // Create engine
            engine = Engine.create();
            engine.world.gravity.y = 1; // Standard gravity

            // Create renderer
            render = Render.create({
                element: document.getElementById('canvas-container'),
                engine: engine,
                options: {
                    width: config.width,
                    height: config.height,
                    wireframes: false,
                    background: '#1a1a1a',
                    pixelRatio: window.devicePixelRatio
                }
            });

            // Create ground
            const ground = Bodies.rectangle(
                config.groundWidth / 2, // Center so it starts at 0 and goes right
                config.height - config.groundHeight / 2,
                config.groundWidth,
                config.groundHeight,
                {
                    isStatic: true,
                    render: { fillStyle: '#333' },
                    label: 'Ground'
                }
            );

            // Add bodies
            Composite.add(engine.world, [ground]);

            // Start simulation
            Render.run(render);
            runner = Runner.create();
            Runner.run(runner, engine);

            // Events
            Events.on(render, 'afterRender', drawOverlay);
            Events.on(engine, 'collisionStart', handleCollision);
            Events.on(engine, 'beforeUpdate', updateTrails);

            // Window resize handling
            window.addEventListener('resize', () => {
                config.width = window.innerWidth;
                config.height = window.innerHeight;

                // Update render bounds
                render.canvas.width = config.width;
                render.canvas.height = config.height;
                render.options.width = config.width;
                render.options.height = config.height;

                // IMPORTANT: Update bounds so we can see the new area
                render.bounds.max.x = config.width;
                render.bounds.max.y = config.height;

                // Reposition Ground
                Body.setPosition(ground, {
                    x: config.groundWidth / 2,
                    y: config.height - config.groundHeight / 2
                });

                // Update cannon Y position to stay on ground
                config.cannonPos.y = config.height - config.groundHeight - 20;

                // Reset world to prevent physics glitches and invalid distances
                // because the "launch point" has effectively moved relative to existing bodies
                resetWorld();
            });
        }

        // --- Game Logic ---

        function fireProjectile() {
            const angleDeg = parseFloat(angleSlider.value);
            const power = parseFloat(powerSlider.value);
            const angleRad = angleDeg * (Math.PI / 180);

            // Determine drag
            let frictionAir = 0;
            if (dragEnabled.checked) {
                frictionAir = 0.01; // Reduced from 0.2 to 0.01 for realism
            }

            // Calculate spawn position at tip of cannon
            const spawnX = config.cannonPos.x + Math.cos(-angleRad) * config.cannonLength;
            const spawnY = config.cannonPos.y + Math.sin(-angleRad) * config.cannonLength;

            const projectile = Bodies.circle(spawnX, spawnY, 10, {
                restitution: 0.5, // Bounciness
                friction: 0.005,
                frictionAir: frictionAir, // Apply user setting
                density: 0.04,
                render: { fillStyle: dragEnabled.checked ? '#ffaa00' : '#00ff88' }, // Different color for drag
                label: 'Projectile',
                collisionFilter: { group: -1 } // Prevent self-collision
            });

            // Store launch data for logging
            projectile.launchAngle = angleDeg;
            projectile.launchPower = power;
            projectile.launchDrag = frictionAir;

            // Calculate velocity vector
            // Negative Y is up in Canvas
            const velocity = {
                x: Math.cos(-angleRad) * power,
                y: Math.sin(-angleRad) * power
            };

            Body.setVelocity(projectile, velocity);
            Composite.add(engine.world, projectile);

            // Track this projectile
            projectiles.push(projectile);
            trails.push([]); // New trail for this projectile
        }

        function handleCollision(event) {
            const pairs = event.pairs;

            pairs.forEach(pair => {
                const bodyA = pair.bodyA;
                const bodyB = pair.bodyB;

                // Check if Projectile hits Ground
                let projectile = null;
                if (bodyA.label === 'Projectile' && bodyB.label === 'Ground') projectile = bodyA;
                else if (bodyB.label === 'Projectile' && bodyA.label === 'Ground') projectile = bodyB;

                if (projectile && !projectile.hasLanded) {
                    // Mark as landed so we don't update distance again for this projectile
                    projectile.hasLanded = true;

                    // Calculate distance
                    // We use the initial x position of the cannon as 0
                    const distancePixels = projectile.position.x - config.cannonPos.x;
                    const distanceMeters = (distancePixels / config.pixelsPerMeter).toFixed(2);

                    // Only update if it's a positive distance and moving forward
                    if (distancePixels > 0) {
                        distanceDisplay.innerText = distanceMeters;

                        // Optional: Stop the ball after a bit or let it roll
                        // To freeze it: Body.setStatic(projectile, true);
                        // We'll let it roll for realism, but maybe dampen it
                        projectile.friction = 0.5;

                        // Visual feedback for landing
                        projectile.render.fillStyle = '#ff0055'; // Change color on impact

                        // Log to table
                        logAttempt(projectile.launchAngle, projectile.launchPower, projectile.launchDrag, distanceMeters);
                    }
                }
            });
        }

        function logAttempt(angle, power, drag, distance) {
            attemptCount++;
            const row = document.createElement('tr');
            row.innerHTML = `
                <td>${attemptCount}</td>
                <td>${angle}째</td>
                <td>${power}</td>
                <td>${drag > 0 ? 'On' : 'Off'}</td>
                <td>${distance}m</td>
            `;
            dataBody.appendChild(row);

            // Auto-scroll the panel
            const panel = document.getElementById('data-panel');
            panel.scrollTop = panel.scrollHeight;
        }

        function updateTrails() {
            // Update trails for active projectiles
            projectiles.forEach((proj, index) => {
                if (!proj.isStatic && proj.position.y < config.height) {
                    // Add current position to trail
                    // Limit trail length for performance if needed, but for simple demo it's fine
                    if (engine.timing.timestamp % 5 === 0) { // Sample every few frames
                        trails[index].push({ ...proj.position });
                    }
                }
            });
        }

        function resetWorld() {
            // Remove all projectiles
            projectiles.forEach(p => Composite.remove(engine.world, p));
            projectiles = [];
            trails = [];
            projectiles = [];
            trails = [];
            distanceDisplay.innerText = "0.0";
            // Optional: Clear table? User might want to keep history. Let's keep it for now.
            // dataBody.innerHTML = ''; 
            // attemptCount = 0;
        }

        // --- Rendering ---

        function drawOverlay() {
            const ctx = render.context;
            const angleDeg = parseFloat(angleSlider.value);
            const angleRad = angleDeg * (Math.PI / 180);

            // Draw Cannon
            ctx.save();
            ctx.translate(config.cannonPos.x, config.cannonPos.y);
            ctx.rotate(-angleRad); // Rotate upwards

            // Cannon Barrel
            ctx.fillStyle = '#666';
            ctx.fillRect(0, -10, config.cannonLength, 20);

            // Cannon Base (visual only)
            ctx.restore();
            ctx.beginPath();
            ctx.arc(config.cannonPos.x, config.cannonPos.y, 20, 0, 2 * Math.PI);
            ctx.fillStyle = '#444';
            ctx.fill();

            // Draw Trails
            ctx.save();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);

            trails.forEach(trail => {
                if (trail.length < 2) return;
                ctx.beginPath();
                ctx.moveTo(trail[0].x, trail[0].y);
                for (let i = 1; i < trail.length; i++) {
                    ctx.lineTo(trail[i].x, trail[i].y);
                }
                ctx.stroke();
            });
            ctx.restore();
        }

        // --- Event Listeners ---

        angleSlider.addEventListener('input', (e) => {
            angleVal.innerText = e.target.value + '째';
        });

        powerSlider.addEventListener('input', (e) => {
            powerVal.innerText = e.target.value;
        });

        dragEnabled.addEventListener('change', (e) => {
            if (e.target.checked) {
                document.body.classList.add('air-mode');
            } else {
                document.body.classList.remove('air-mode');
            }
        });

        btnFire.addEventListener('click', fireProjectile);
        btnReset.addEventListener('click', resetWorld);

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') fireProjectile();
            if (e.code === 'KeyR') resetWorld();
        });

        // Initialize
        init();

    </script>
</body>

</html>